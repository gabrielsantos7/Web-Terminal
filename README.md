# üêß Linux Interactive Web Terminal

## üé¨ Demonstra√ß√£o em V√≠deo

[Clique aqui](https://youtu.be/LxXPw16eRJk) para assistir o v√≠deo.

## üìÉ Descri√ß√£o

O **Linux Interactive Web Terminal** √© um de meus projetos mais criativos e sofisticados. N√£o poderia entregar menos como projeto final para um curso de excel√™ncia t√£o not√≥ria como o CS50x. Em resumo, trata-se de uma aplica√ß√£o que busca simular um terminal Linux na web, com a paleta de cores inspirada nos terminais da distribui√ß√£o Ubuntu.

O usu√°rio consegue interagir com o terminal atrav√©s de dois modos diferentes: O primeiro, que vem por padr√£o, √© o modo `command`, onde ele deve informar comandos reais que usaria em um terminal comum. A aplica√ß√£o ent√£o analisar√° se o comando √© v√°lido, e caso seja, retornar√° uma breve descri√ß√£o do que aquele comando faz. No segundo modo (`action`), o usu√°rio informa a a√ß√£o que deseja executar, explicando o que ele gostaria que fosse feito, e o terminal exibir√° um comando correspondente ao que foi solicitado pelo usu√°rio.

Tudo isso √© poss√≠vel gra√ßas ao uso da **API do Google Gemini**, que permite integrar o servi√ßo de intelig√™ncia artificial √† nossa aplica√ß√£o. Para isso, foi constru√≠do um backend com **Node** e **Express**, que recebe um prompt, encaminha-o para essa API e retorna a resposta gerada pela IA. A infraestrutura √© relativamente simples, pois seu objetivo √© simplesmente intermerdiar a comunica√ß√£o entre o servi√ßo de IA e a interface de usu√°rio, limitando o tamanho do prompt e o n√∫mero de requisi√ß√µes que o servidor aceita por usu√°rio em um intervalo de tempo.

No desenvolvimento do frontend, foi utilizada uma das bibliotecas mais populares e modernas do mercado, o **React**. Essa biblioteca facilita a constru√ß√£o de interfaces de usu√°rio interativas e din√¢micas. Para potencializar a produtividade e a seguran√ßa do c√≥digo, o projeto foi implementado em **TypeScript**, uma linguagem que expande as funcionalidades do JavaScript, fornecendo tipagem est√°tica e outras funcionalidades avan√ßadas. Na parte de estiliza√ß√£o, optei pelo uso do **Tailwind CSS**, uma biblioteca de classes utilit√°rias que permite construir interfaces visualmente agrad√°veis de forma r√°pida e eficiente.

Para a estrutura√ß√£o de pastas e arquivos do projeto, optei pelo padr√£o mais usado pela comunidade, em que todo o c√≥digo fonte √© armazenado dentro da pasta `src`. Ela √© subdivida entre duas outras pastas: `components`, que armazena os componentes React da aplica√ß√£o, e `services`, que √© respons√°vel pela camada de requisi√ß√µes HTTP para o servidor, enviando o prompt do usu√°rio e retornando a resposta gerada. Optei pelo uso da biblioteca **Axios**, que torna mais f√°cil o processo de envio de requisi√ß√µes e tratamento de erros e respostas.

Dentro da pasta `src`, existem outros arquivos importantes: `app.tsx` e `main.tsx` s√£o arquivos definidos pelo pr√≥prio React. Podemos dizer que o componente `App` √© o componente principal da aplica√ß√£o, que gerencia toda a l√≥gica de funcionamento do terminal. Ele √© renderizado no arquivo `main.tsx`, que o define sendo o componente ra√≠z da aplica√ß√£o. Os arquivos `helpers.ts` e `models.ts` representam, respectivamente, fun√ß√µes utilit√°rias que auxiliar√£o no funcionamento geral da aplica√ß√£o, e defini√ß√£o de interfaces, que descrevem as propriedades de elementos da aplica√ß√£o. Em toda a aplica√ß√£o, utilizamos apenas um arquivo CSS (`index.css`), tamb√©m localizado dentro dessa pasta. √â nesse arquivo que s√£o definidas as diretivas do Tailwind CSS, indispens√°veis para seu funcionamento correto, e algumas estiliza√ß√µes gerais que ser√£o aplicadas em toda a aplica√ß√£o.

Na subpasta `services`, s√£o definidos dois arquivos: `axios.ts` e `get-command-description.ts`. O primeiro arquivo tem como objetivo a cria√ß√£o e exporta√ß√£o de uma √∫nica inst√¢ncia do Axios, definindo as configura√ß√µes necess√°rias para seu funcionamento, a fim de evitar a cria√ß√£o de m√∫ltiplas inst√¢ncias. O segundo arquivo utiliza essa inst√¢ncia do Axios para realizar o envio do prompt do usu√°rio para o backend e retornar a resposta gerada. Esse processo √© feito atrav√©s de uma fun√ß√£o, que √© exportada para ser usada dentro do componente principal.

Na subpasta `components`, temos a defini√ß√£o dos componentes do terminal que representam diferentes partes essenciais da interface e funcionalidade do terminal web. Cada componente desempenha um papel espec√≠fico na simula√ß√£o da experi√™ncia de linha de comando, como a exibi√ß√£o do banner principal, a estrutura de um comando digitado, o nome de usu√°rio com o hor√°rio atual, a listagem dos comandos dispon√≠veis, um elemento que representa o cursor do terminal e outro que exibe as principais informa√ß√µes do projeto, como objetivo e tecnologias usadas.

O resultado final foi uma aplica√ß√£o web que simula um terminal de linha de comando, onde o usu√°rio pode interagir com diferentes comandos e receber respostas imediatas, sem precisar recarregar a p√°gina, proporcionando uma experi√™ncia din√¢mica, fluida e intuitiva. Usei como inspira√ß√£o um projeto feito por `FK Codes`, que tamb√©m simula uma aplica√ß√£o como essa. Voc√™ pode acess√°-la [clicando aqui](https://fkcodes.com/). Espero que esse projeto cumpra com o que foi proposto pelo CS50x e que talvez possa ajudar a quem est√° migrando para o Linux ou deseje aprofundar seu conhecimento em alguma distribui√ß√£o.
